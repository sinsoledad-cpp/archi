networks:
  net01:
    driver: bridge

services:

#----------------------------------------------------------------------------------------------
  #mysql环境# https://github.com/bitnami/containers/tree/main/bitnami/mysql#how-to-use-this-image
  # todo sudo rm -rf mysql ; sudo mkdir -p mysql/data mysql/conf  && sudo chown -R 1001:1001 mysql &&  sudo docker pull registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 && sudo docker tag registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 bitnami/mysql:8.0
  mysql:
    image: bitnami/mysql:8.0  # sudo docker pull registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 && sudo docker tag registry.cn-guangzhou.aliyuncs.com/dbinggo-bitnami/mysql:8.0 bitnami/mysql:8.0
    container_name: mysql # 强制指定容器的名称为 mysql
    hostname: mysql # 设置容器内部的主机名为 mysql
    restart: unless-stopped
#    privileged: true # 特权模式
    ports:
      - "3306:3306"
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: root
#    volumes:
#      - "./mysql/data:/bitnami/mysql/data" # sudo rm -rf mysql ; sudo mkdir mysql && sudo chown -R 1001:1001 mysql
#      - "./mysql/conf:/opt/bitnami/mysql/conf"
    networks:
      - net01
    healthcheck:
      test: [ 'CMD', '/opt/bitnami/scripts/mysql/healthcheck.sh' ]
      interval: 10s
      timeout: 5s
      retries: 6
#----------------------------------------------------------------------------------------------
  redis:
    image: "bitnami/redis:latest"
    container_name: redis # 强制指定容器的名称为 mysql
    hostname: redis # 设置容器内部的主机名为 mysql
    restart: unless-stopped
    ports:
      - '6379:6379'
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
    networks:
      - net01
#----------------------------------------------------------------------------------------------
  kafka:
    image: bitnami/kafka:3.9.0
    container_name: kafka
    restart: unless-stopped
    ports:
      - "9092:9092"    # 外部客户端 (如您的Go程序) 连接端口
      - "9093:9093"    # 控制器通信端口 (通常无需暴露给主机，但保留亦可)
    environment:
      # KRaft 模式配置
      - KAFKA_ENABLE_KRAFT=yes
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_NODE_ID=1
      # 1.【关键修改】使用服务名'kafka'代替IP地址，这是Docker网络内部的通信方式
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093

      # 监听器配置
      # 2.【关键修改】定义了三个监听器：
      # EXTERNAL: 用于外部客户端（您的Go程序）连接
      # INTERNAL: 用于内部容器间（Kafka与Kafdrop）通信
      # CONTROLLER: 用于KRaft控制器通信
      - KAFKA_CFG_LISTENERS=EXTERNAL://:9092,INTERNAL://:29092,CONTROLLER://:9093

      # 3.【关键修改】对外公告的地址
      # EXTERNAL 公告为 localhost，供您的主机Go程序使用
      # INTERNAL 公告为 kafka服务名+内部端口，供Kafdrop使用
      - KAFKA_CFG_ADVERTISED_LISTENERS=EXTERNAL://localhost:9092,INTERNAL://kafka:29092

      # 安全协议映射（增加了EXTERNAL）
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT

      # Broker间通信使用内部监听器
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=INTERNAL
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
    networks:
      - net01

  kafdrop:
    image: obsidiandynamics/kafdrop:latest
    container_name: kafdrop
    restart: unless-stopped
    ports:
      - "19000:9000"  # 将Kafdrop的UI端口映射到主机的19000端口
    environment:
      - KAFKA_BROKERCONNECT=kafka:29092 # Kafdrop 通过 Kafka 的内部监听器进行连接
    depends_on:
      - kafka
    networks:
      - net01
#----------------------------------------------------------------------------------------------
  # Elasticsearch 服务
  es:
    image: elasticsearch:7.12.0
    container_name: es
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms256m -Xmx512m  # 注意：我将 Xms 稍微提高以保证稳定性
      - "TZ=Asia/Shanghai" # 设置时区为上海
#    volumes:
#      - E:\Docker\es\config\elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
#      - E:\Docker\es\data:/usr/share/elasticsearch/data
#      - E:\Docker\es\plugins:/usr/share/elasticsearch/plugins
    ports:
      - "9200:9200"
      - "9300:9300"
    networks:
      - net01

  # Kibana 服务
  kibana:
    image: kibana:7.12.0
    container_name: kibana
    restart: unless-stopped
    environment:
      # 关键配置：告诉 Kibana 去哪里找 Elasticsearch
      # 'es' 是上面定义的 Elasticsearch 服务的名称
      - ELASTICSEARCH_HOSTS=http://es:9200
      - "TZ=Asia/Shanghai" # 设置时区为上海
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=xxxxxx
    ports:
      - "5601:5601"
    depends_on:
      - es  # 确保 Kibana 在 Elasticsearch 启动之后再启动
    networks:
      - net01
  # Prometheus 服务
  prometheus:
    image: prom/prometheus:v2.47.2
    container_name: prometheus
    restart: unless-stopped
    volumes:
      - ./scripts/prometheus/prometheus.yaml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    networks:
      - net01
    healthcheck: # 补充：健康检查（进阶）
      test: [ "CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9090/-/healthy" ]
      interval: 30s
      timeout: 10s
      retries: 3
  # Zipkin 服务
  zipkin:
    image: openzipkin/zipkin-slim:2.24
    container_name: zipkin_server
    restart: unless-stopped
    ports:
      - '9411:9411'
    networks:
      - net01
  # Grafana 服务
  grafana:
    image: grafana/grafana-enterprise:10.2.0
    container_name: grafana # 增加：指定一个固定的容器名
    restart: unless-stopped # 5. 核心补充：重启策略
    ports:
      - "3000:3000"
#    volumes:
#      # 核心补充：数据持久化
#      - grafana_data:/var/lib/grafana
    environment: # 核心补充：配置环境变量
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=your_strong_password_here # 请修改为你的强密码
      - GF_USERS_ALLOW_SIGN_UP=false # 禁止新用户自行注册
    networks:
      - net01 # 核心补充：加入 Prometheus 所在网络
    healthcheck: # 补充：健康检查（进阶）
      test: [ "CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost:3000/api/health || exit 1" ]
      interval: 30s
      timeout: 10s
      retries: 3